<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solana Bundler</title>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Courier New', monospace; }
        body { background: #000; color: #0f0; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        h1 { color: #0ff; margin-bottom: 20px; }
        .section { background: #111; border: 1px solid #0f0; padding: 20px; margin-bottom: 20px; }
        input, textarea, button { 
            background: #000; 
            color: #0f0; 
            border: 1px solid #0f0; 
            padding: 10px; 
            margin: 5px 0;
            font-family: 'Courier New', monospace;
        }
        button { cursor: pointer; font-weight: bold; }
        button:hover { background: #0f0; color: #000; }
        textarea { width: 100%; height: 100px; }
        input[type="number"] { width: 200px; }
        .log { background: #000; border: 1px solid #333; padding: 10px; height: 400px; overflow-y: auto; font-size: 12px; }
        .log div { margin: 2px 0; }
        .info { color: #0ff; }
        .success { color: #0f0; }
        .error { color: #f00; }
        .warning { color: #ff0; }
        .wallet-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; }
        .wallet-card { background: #000; border: 1px solid #333; padding: 10px; font-size: 11px; }
        .wallet-card.funded { border-color: #0f0; }
        .hidden { display: none; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ö° SOLANA BUNDLER</h1>
        
        <!-- Import Section -->
        <div id="importSection" class="section">
            <h2>üîë IMPORT WALLET</h2>
            <p style="color: #888; margin: 10px 0;">Paste your Pump.fun wallet private key (Base58 or array format)</p>
            <textarea id="privateKeyInput" placeholder="Paste private key here..."></textarea>
            <button onclick="loadWallet()">LOAD WALLET</button>
        </div>
        
        <!-- Main Dashboard -->
        <div id="mainDashboard" class="hidden">
            <div class="grid-2">
                <div>
                    <div class="section">
                        <h2>üí∞ MAIN WALLET</h2>
                        <p>Balance: <span id="mainBalance">0.0000 SOL</span></p>
                        <p style="font-size: 11px; color: #888; margin-top: 5px;" id="mainAddress">Not loaded</p>
                    </div>
                    
                    <div class="section">
                        <h2>üí∏ FUND WALLETS</h2>
                        <p style="color: #ff0; margin: 10px 0;">üß™ Test mode: 0.002 SOL = 2 wallets</p>
                        <p style="color: #0f0; margin: 10px 0;">üöÄ Full mode: 0.018 SOL = 20 wallets</p>
                        <input type="number" id="fundAmount" value="0.002" step="0.001" min="0.002">
                        <button onclick="fundWallets()">FUND</button>
                    </div>
                    
                    <div class="section">
                        <h2>üîÑ SWEEP ALL</h2>
                        <p style="color: #888; margin: 10px 0;">Return all SOL from sub-wallets to main wallet</p>
                        <button onclick="sweepAll()">SWEEP</button>
                    </div>
                </div>
                
                <div>
                    <div class="section">
                        <h2>üìã LOGS <button onclick="clearLogs()" style="float: right; padding: 5px 10px;">CLEAR</button></h2>
                        <div id="logContainer" class="log">
                            <div class="info">Ready...</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h2>üéØ SUB-WALLETS (20)</h2>
                <div id="walletsContainer" class="wallet-grid"></div>
            </div>
        </div>
    </div>

    <!-- Load Solana Web3 with fallback -->
    <script src="https://unpkg.com/@solana/web3.js@1.87.6/lib/index.iife.min.js" 
            onerror="loadFallbackScript()"></script>
    
    <script>
        // Fallback script loader
        function loadFallbackScript() {
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/@solana/web3.js@1.87.6/lib/index.iife.min.js';
            script.onerror = function() {
                alert('ERROR: Cannot load Solana library from any CDN.\n\nPlease check your internet connection and refresh.');
            };
            document.head.appendChild(script);
        }
        
        // Wait a moment for script to load, then initialize
        setTimeout(function() {
            if (typeof solanaWeb3 === 'undefined') {
                alert('ERROR: Solana library failed to load.\n\nTrying fallback CDN...');
                loadFallbackScript();
                // Wait again for fallback
                setTimeout(initializeBundler, 2000);
            } else {
                initializeBundler();
            }
        }, 1000);
        
        function initializeBundler() {
            if (typeof solanaWeb3 === 'undefined') {
                alert('FATAL ERROR: Solana library could not load.\n\nPlease refresh and try again.');
                return;
            }
            
            const { Connection, Keypair, Transaction, SystemProgram, LAMPORTS_PER_SOL, PublicKey } = solanaWeb3;
            
            // Global variables
            let mainWallet = null;
            let publicKey = null;
            let connection = null;
            let balanceConnection = null;
            let subWallets = [];
            let isBusy = false;
            
            // Initialize connections
            connection = new Connection('https://frequent-cosmopolitan-thunder.solana-mainnet.quiknode.pro/3108ed2d47a7f31953201358cdef57f0cf652e77/', 'confirmed');
            balanceConnection = new Connection('https://api.mainnet-beta.solana.com', 'confirmed');
            
            log('info', 'üöÄ Bundler initialized');
            log('info', 'üåê QuickNode RPC for transactions');
            log('info', 'üí∞ Public RPC for balance checks');
            
            // Load wallet function
            window.loadWallet = async function() {
                // Remove ALL whitespace, newlines, tabs
                const pkInput = document.getElementById('privateKeyInput').value.replace(/\s+/g, '').trim();
                
                if (!pkInput) {
                    alert('Please paste your private key!');
                    return;
                }
                
                log('info', 'üîë Loading wallet...');
                log('info', `Key length: ${pkInput.length} characters`);
                
                try {
                    let secretKey;
                    
                    // Try array format
                    if (pkInput.startsWith('[')) {
                        log('info', 'Parsing array format...');
                        const arr = JSON.parse(pkInput);
                        if (arr.length !== 64) {
                            throw new Error(`Array must be 64 bytes, got ${arr.length}`);
                        }
                        secretKey = Uint8Array.from(arr);
                    } 
                    // Try Base58
                    else {
                        log('info', 'Parsing Base58 format...');
                        
                        try {
                            // Manual Base58 decoder (solanaWeb3.bs58 doesn't exist in v1.87.6)
                            const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
                            const bytes = [0];
                            
                            for (let i = 0; i < pkInput.length; i++) {
                                const c = pkInput[i];
                                const value = ALPHABET.indexOf(c);
                                if (value === -1) {
                                    throw new Error(`Invalid Base58 character: ${c}`);
                                }
                                
                                for (let j = 0; j < bytes.length; j++) bytes[j] *= 58;
                                bytes[0] += value;
                                
                                let carry = 0;
                                for (let j = 0; j < bytes.length; j++) {
                                    bytes[j] += carry;
                                    carry = bytes[j] >> 8;
                                    bytes[j] &= 0xff;
                                }
                                
                                while (carry > 0) {
                                    bytes.push(carry & 0xff);
                                    carry >>= 8;
                                }
                            }
                            
                            // Add leading zeros
                            for (let i = 0; i < pkInput.length && pkInput[i] === '1'; i++) {
                                bytes.push(0);
                            }
                            
                            secretKey = new Uint8Array(bytes.reverse());
                        } catch (decodeError) {
                            log('error', `Decode error: ${decodeError.message}`);
                            throw new Error(`Failed to decode Base58: ${decodeError.message}`);
                        }
                        
                        log('success', `‚úì Decoded ${secretKey.length} bytes`);
                        
                        if (secretKey.length !== 64) {
                            throw new Error(`Key must be 64 bytes, got ${secretKey.length} bytes`);
                        }
                    }
                    
                    log('success', '‚úì Private key decoded');
                    
                    mainWallet = Keypair.fromSecretKey(secretKey);
                    publicKey = mainWallet.publicKey;
                    
                    log('success', `‚úì Wallet loaded: ${publicKey.toString().slice(0,8)}...`);
                    
                    // Load sub-wallets from JSON
                    log('info', 'üìÅ Loading 20 pre-generated wallets...');
                    
                    const response = await fetch('bundler-wallet-keys.json');
                    if (!response.ok) {
                        throw new Error('Could not load bundler-wallet-keys.json file!');
                    }
                    
                    const data = await response.json();
                    
                    if (!data.wallets || data.wallets.length !== 20) {
                        throw new Error('Invalid wallet file!');
                    }
                    
                    subWallets = [];
                    for (let i = 0; i < 20; i++) {
                        const w = data.wallets[i];
                        const keypair = Keypair.fromSecretKey(Uint8Array.from(w.secretKey));
                        subWallets.push({
                            keypair: keypair,
                            balance: 0,
                            status: 'empty'
                        });
                    }
                    
                    log('success', '‚úì Loaded 20 wallets!');
                    
                    document.getElementById('mainAddress').textContent = publicKey.toString();
                    document.getElementById('importSection').classList.add('hidden');
                    document.getElementById('mainDashboard').classList.remove('hidden');
                    
                    renderWallets();
                    updateBalance();
                    
                    log('success', '‚úÖ Ready to fund & sweep!');
                    
                } catch (error) {
                    log('error', `‚ùå ${error.message}`);
                    alert(`Failed to load wallet!\n\n${error.message}`);
                }
            };
            
            // Update balance
            async function updateBalance() {
                if (!publicKey) return;
                try {
                    const balance = await balanceConnection.getBalance(publicKey);
                    const sol = (balance / LAMPORTS_PER_SOL).toFixed(4);
                    document.getElementById('mainBalance').textContent = sol + ' SOL';
                } catch (e) {
                    document.getElementById('mainBalance').textContent = 'ERROR';
                }
            }
            
            // Fund wallets
            window.fundWallets = async function() {
                if (!mainWallet) {
                    alert('Load wallet first!');
                    return;
                }
                
                if (isBusy) {
                    alert('Busy...');
                    return;
                }
                
                const totalAmount = parseFloat(document.getElementById('fundAmount').value);
                if (isNaN(totalAmount) || totalAmount <= 0) {
                    alert('Invalid amount!');
                    return;
                }
                
                const testMode = totalAmount < 0.01;
                const numWallets = testMode ? 2 : 20;
                
                isBusy = true;
                
                if (testMode) {
                    log('warning', 'üß™ TEST MODE: Funding 2 wallets');
                } else {
                    log('info', 'üöÄ FULL MODE: Funding 20 wallets');
                }
                
                try {
                    const amountPerWallet = totalAmount / numWallets;
                    const lamportsPerWallet = Math.floor(amountPerWallet * LAMPORTS_PER_SOL);
                    
                    if (lamportsPerWallet < 890880) {
                        throw new Error(`Too small! Need ${((890880 * numWallets) / LAMPORTS_PER_SOL).toFixed(4)} SOL minimum`);
                    }
                    
                    log('info', `üìä ${numWallets} wallets √ó ${amountPerWallet.toFixed(6)} SOL`);
                    
                    const { blockhash } = await connection.getLatestBlockhash('finalized');
                    log('success', '‚úì Got blockhash');
                    
                    const tx = new Transaction();
                    tx.recentBlockhash = blockhash;
                    tx.feePayer = publicKey;
                    
                    for (let i = 0; i < numWallets; i++) {
                        tx.add(SystemProgram.transfer({
                            fromPubkey: publicKey,
                            toPubkey: subWallets[i].keypair.publicKey,
                            lamports: lamportsPerWallet
                        }));
                    }
                    
                    tx.sign(mainWallet);
                    
                    log('info', 'üì§ Sending...');
                    
                    const sig = await connection.sendRawTransaction(tx.serialize(), {
                        skipPreflight: true
                    });
                    
                    log('success', `‚úì Sent! ${sig.slice(0,16)}...`);
                    log('info', `üîó https://solscan.io/tx/${sig}`);
                    log('info', '‚è≥ Confirming...');
                    
                    let confirmed = false;
                    for (let i = 0; i < 30; i++) {
                        const status = await connection.getSignatureStatus(sig);
                        if (status.value?.confirmationStatus === 'confirmed' || status.value?.confirmationStatus === 'finalized') {
                            if (!status.value?.err) {
                                confirmed = true;
                                break;
                            } else {
                                throw new Error('Transaction failed');
                            }
                        }
                        await sleep(2000);
                    }
                    
                    if (!confirmed) {
                        throw new Error('Timeout');
                    }
                    
                    log('success', '‚úÖ CONFIRMED!');
                    
                    for (let i = 0; i < numWallets; i++) {
                        subWallets[i].balance = amountPerWallet;
                        subWallets[i].status = 'funded';
                    }
                    
                    renderWallets();
                    updateBalance();
                    
                    log('success', `üéâ ${numWallets} wallets funded!`);
                    log('warning', '‚ö†Ô∏è Now click SWEEP to test!');
                    
                } catch (error) {
                    log('error', `‚ùå ${error.message}`);
                    alert(`Error: ${error.message}`);
                } finally {
                    isBusy = false;
                }
            };
            
            // Sweep all
            window.sweepAll = async function() {
                if (!mainWallet) {
                    alert('Load wallet first!');
                    return;
                }
                
                if (isBusy) {
                    alert('Busy...');
                    return;
                }
                
                if (!confirm('Sweep all wallets?')) {
                    return;
                }
                
                isBusy = true;
                log('info', 'üßπ Sweeping...');
                
                let totalSwept = 0;
                let successCount = 0;
                
                try {
                    const { blockhash } = await connection.getLatestBlockhash('finalized');
                    
                    for (let i = 0; i < 20; i++) {
                        const wallet = subWallets[i];
                        
                        try {
                            let balance = 0;
                            try {
                                balance = await balanceConnection.getBalance(wallet.keypair.publicKey);
                                log('info', `üí∞ Wallet ${i+1}: ${balance} lamports`);
                            } catch (e) {
                                log('warning', `‚ö†Ô∏è Wallet ${i+1}: Can't check balance`);
                                continue;
                            }
                            
                            if (balance < 5000) continue;
                            
                            const transferAmount = balance - 5000;
                            
                            log('info', `üì§ Wallet ${i+1}: Sweeping...`);
                            
                            const tx = new Transaction();
                            tx.recentBlockhash = blockhash;
                            tx.feePayer = wallet.keypair.publicKey;
                            tx.add(SystemProgram.transfer({
                                fromPubkey: wallet.keypair.publicKey,
                                toPubkey: publicKey,
                                lamports: transferAmount
                            }));
                            tx.sign(wallet.keypair);
                            
                            const sig = await connection.sendRawTransaction(tx.serialize(), {
                                skipPreflight: true
                            });
                            
                            let confirmed = false;
                            for (let attempt = 0; attempt < 20; attempt++) {
                                const status = await connection.getSignatureStatus(sig);
                                if (status.value?.confirmationStatus === 'confirmed' || status.value?.confirmationStatus === 'finalized') {
                                    if (!status.value?.err) {
                                        confirmed = true;
                                        break;
                                    }
                                }
                                await sleep(2000);
                            }
                            
                            if (confirmed) {
                                const solAmount = transferAmount / LAMPORTS_PER_SOL;
                                totalSwept += solAmount;
                                successCount++;
                                log('success', `‚úÖ Wallet ${i+1}: ${solAmount.toFixed(6)} SOL`);
                                subWallets[i].balance = 0;
                                subWallets[i].status = 'empty';
                            }
                            
                            await sleep(1000);
                            
                        } catch (error) {
                            log('warning', `‚ö†Ô∏è Wallet ${i+1}: ${error.message}`);
                        }
                    }
                    
                    log('success', '‚úÖ SWEEP COMPLETE!');
                    log('success', `‚úÖ Success: ${successCount} wallets`);
                    log('success', `‚úÖ Returned: ${totalSwept.toFixed(6)} SOL`);
                    
                    renderWallets();
                    updateBalance();
                    
                    alert(`‚úÖ SWEEP COMPLETE!\n\n${successCount} wallets\n${totalSwept.toFixed(6)} SOL returned`);
                    
                } catch (error) {
                    log('error', `‚ùå ${error.message}`);
                    alert(`Error: ${error.message}`);
                } finally {
                    isBusy = false;
                }
            };
            
            // Render wallets
            function renderWallets() {
                const container = document.getElementById('walletsContainer');
                container.innerHTML = '';
                
                subWallets.forEach((w, i) => {
                    const card = document.createElement('div');
                    card.className = 'wallet-card' + (w.status === 'funded' ? ' funded' : '');
                    card.innerHTML = `
                        <div style="color: #888;">#${i+1}</div>
                        <div style="color: ${w.status === 'funded' ? '#0f0' : '#555'};">${w.status.toUpperCase()}</div>
                        <div style="color: #888; margin: 5px 0;">${w.keypair.publicKey.toString().slice(0,8)}...</div>
                        <div>${w.balance.toFixed(4)} SOL</div>
                    `;
                    container.appendChild(card);
                });
            }
            
            // Log function
            function log(type, message) {
                const container = document.getElementById('logContainer');
                const time = new Date().toLocaleTimeString();
                const div = document.createElement('div');
                div.className = type;
                div.textContent = `[${time}] ${message}`;
                container.appendChild(div);
                container.scrollTop = container.scrollHeight;
            }
            
            // Clear logs
            window.clearLogs = function() {
                document.getElementById('logContainer').innerHTML = '<div class="info">Logs cleared</div>';
            };
            
            // Sleep helper
            function sleep(ms) {
                return new Promise(r => setTimeout(r, ms));
            }
        }
    </script>
</body>
</html>
